#include "btree_mgr.h"#include "tables.h"#include "buffer_mgr.h"#include "record_mgr.h"#include "storage_mgr.h"#include <stdio.h>#include <stdlib.h>#include <string.h>typedef struct bTree{    struct Value value;    struct RID rid;}bTree;#define MAKE_BTREEMANAGER() (bTree **)malloc(100*sizeof(bTree*))#define MAKE_BTREEHANDLE() (BTreeHandle *)malloc(sizeof(BTreeHandle)*3)#define MAKE_BTREE() (bTree *)malloc(sizeof(bTree))int numEntry;int nextEn;bTree **bTreeMana;/************************************************************************** • function name   initIndexManager  • description   initial index manger  • parameters   void *mgmtData  • return value   return RC_OK ***************************************************************************/RC initIndexManager (void *mgmtData){        bTreeMana=MAKE_BTREEMANAGER();    return RC_OK;}/************************************************************************** • function name   shutdownIndexManager  • description   shut down index manger  • parameters   void  • return value   return RC_OK ***************************************************************************/RC shutdownIndexManager (){    free(bTreeMana);    return RC_OK;}/************************************************************************** • function name   createBtree  • description   create a B-Tree   • parameters   char *idxId, DataType keyType, int n  • return value   return ret ***************************************************************************/RC createBtree (char *idxId, DataType keyType, int n){    int ret=0;    if(idxId==NULL){        printf("FILE NAME IS NULL\n");        return RC_REC_FILE_NOT_FOUND;    } else{        BTreeHandle *btree= MAKE_BTREEHANDLE();        btree->idxId=idxId;        btree->keyType=keyType;        numEntry=0;        nextEn=0;    }    return ret;}/************************************************************************** • function name   openBtree  • description   open a B-Tree  • parameters   BTreeHandle **tree, char *idxId  • return value   return Ret ***************************************************************************/RC openBtree (BTreeHandle **tree, char *idxId){    int ret=0;    if(idxId==NULL){        printf("FILE NAME IS NULL\n");        return RC_REC_FILE_NOT_FOUND;    }else{        *tree=MAKE_BTREEHANDLE();        (*tree)-> idxId=(char*)malloc(sizeof(char)*4);        (*tree)-> idxId= idxId;        return ret;    }}/************************************************************************** • function name   closeBtree  • description   close a B-Tree  • parameters   BTreeHandle *tree  • return value   return RC_OK ***************************************************************************/RC closeBtree (BTreeHandle *tree){    free(tree);    return RC_OK;}/************************************************************************** • function name   deleteBtree  • description   delete a B-Tree  • parameters   char *idxId  • return value   return ret ***************************************************************************/RC deleteBtree (char *idxId){    int ret=0;    if(idxId==NULL){        printf("FILE NAME IS NULL\n");        return RC_REC_FILE_NOT_FOUND;    }else{        numEntry=0;        nextEn=0;        return ret;    }}/************************************************************************** • function name   getNumNodes  • description   get the number of nodes of a B-Tree  • parameters   BTreeHandle *tree, int *result  • return value   return RC_OK ***************************************************************************/RC getNumNodes (BTreeHandle *tree, int *result){    int i=1;    int j=1;    int counter=0;    int numNode=0;    bool flag;    while(i< numEntry){        j=i-1;        while(j>= 0){            flag=bTreeMana[i]->rid.page==bTreeMana[j]->rid.page;            if(flag){                counter++;                break;            }            j--;        }        i++;    }    numNode=numEntry-counter;    *result= numNode;    return RC_OK;}/************************************************************************** • function name   getNumEntries  • description   get the number of entries of a B-Tree  • parameters   BTreeHandle *tree, int *result  • return value   return ret ***************************************************************************/RC getNumEntries (BTreeHandle *tree, int *result){    int ret=0;    *result=numEntry;    return ret;}/************************************************************************** • function name   getKeyType  • description   get the key type of a B-Tree  • parameters   BTreeHandle *tree, DataType *result  • return value   return ret ***************************************************************************/RC getKeyType (BTreeHandle *tree, DataType *result){    int ret=0;    *result=tree->keyType;    return ret;}/************************************************************************** • function name   findKey  • description   find RID of a key  • parameters   BTreeHandle *tree, Value *key, RID *result  • return value   return RC ***************************************************************************/RC findKey (BTreeHandle *tree, Value *key, RID *result){    int i=0;    bool flag=key->dt==DT_INT;    if(flag){        while(i< numEntry){            bool flag1=bTreeMana[i]->value.dt==key->dt&& bTreeMana[i]->value.v.intV==key->v.intV;            if(flag1){                result->page=bTreeMana[i]->rid.page;                result->slot=bTreeMana[i]->rid.slot;                return RC_OK;            }            i++;        }    }    return RC_IM_KEY_NOT_FOUND;}/************************************************************************** • function name   insertKey  • description   insert a key to the B-Tree  • parameters   BTreeHandle *tree, Value *key, RID rid  • return value   return RC ***************************************************************************/RC insertKey (BTreeHandle *tree, Value *key, RID rid){    bTreeMana[numEntry]=MAKE_BTREE();    bool flag=key->dt== DT_INT;    bool exist= FALSE;    int i=0;    if(flag){        while(i<numEntry){            bool flag1=bTreeMana[i]->value.dt==key->dt && bTreeMana[i]->value.v.intV==key->v.intV;            if(flag1){                exist= TRUE;                return RC_IM_KEY_ALREADY_EXISTS;            }            i++;        }                if(exist==FALSE){            bTreeMana[numEntry]->value.dt=key->dt;            bTreeMana[numEntry]->value.v.intV=key->v.intV;            bTreeMana[numEntry]->rid.page=rid.page;            bTreeMana[numEntry]->rid.slot=rid.slot;        }    }    numEntry++;    return RC_OK;}/************************************************************************** • function name   deleteKey  • description   delete a key from a B-Tree  • parameters   BTreeHandle *tree, Value *key  • return value   return RC ***************************************************************************/RC deleteKey (BTreeHandle *tree, Value *key){    int i,j;    int temp=0;    bool flag=key->dt ==DT_INT;    bool exist=FALSE;    //first check if this key already exists    if (flag) {        for(i=0;i<numEntry;i++)        {            bool flag2=bTreeMana[i]->value.dt==key->dt && bTreeMana[i]->value.v.intV==key->v.intV;            if(flag2)            {                exist =TRUE;                temp=i+1;                for(j=i;j<numEntry&&temp<numEntry;j++)                {                                        bTreeMana[j]->value.dt=bTreeMana[temp]->value.dt;                    bTreeMana[j]->value.v.intV=bTreeMana[temp]->value.v.intV;                    bTreeMana[j]->rid.page=bTreeMana[temp]->rid.page;                    bTreeMana[j]->rid.slot=bTreeMana[temp]->rid.slot;                    temp++;                }                numEntry--;                free(bTreeMana[j]);                return RC_OK;            }        }    }    return RC_IM_KEY_NOT_FOUND;}/************************************************************************** • function name   openBtreeScan  • description   open a tree scan  • parameters   BTreeHandle *tree, BT_ScanHandle **handle  • return value return RC_OK ***************************************************************************/RC openTreeScan (BTreeHandle *tree, BT_ScanHandle **handle){    return RC_OK;}/************************************************************************** • function name   nextEntry  • description   get the next record by the ordered slot id and page id  • parameters   BT_ScanHandle *handle, RID *result  • return value   return RC ***************************************************************************/RC nextEntry (BT_ScanHandle *handle, RID *result){    //sort    int i,k;    Value value_temp;    RID rid_temp;    for(i=0;i<numEntry-1;i++)    {        int temp=i;        for(k=i+1;k<numEntry;k++)        {            bool flag=bTreeMana[k]->value.v.intV<bTreeMana[temp]->value.v.intV;            if(flag)            {                temp=k;            }        }                value_temp.dt=bTreeMana[i]->value.dt;        value_temp.v.intV=bTreeMana[i]->value.v.intV;        rid_temp.page=bTreeMana[i]->rid.page;        rid_temp.slot=bTreeMana[i]->rid.slot;                bTreeMana[i]->value.dt=bTreeMana[temp]->value.dt;        bTreeMana[i]->value.v.intV=bTreeMana[temp]->value.v.intV;        bTreeMana[i]->rid.page=bTreeMana[temp]->rid.page;        bTreeMana[i]->rid.slot=bTreeMana[temp]->rid.slot;                bTreeMana[temp]->value.dt=value_temp.dt;        bTreeMana[temp]->value.v.intV=value_temp.v.intV;        bTreeMana[temp]->rid.page=rid_temp.page;        bTreeMana[temp]->rid.slot=rid_temp.slot;            }        if(nextEn>=numEntry)    {        return RC_IM_NO_MORE_ENTRIES;            }    else    {        result->page=bTreeMana[nextEn]->rid.page;        result->slot=bTreeMana[nextEn]->rid.slot;        nextEn++;        return RC_OK;    }    }/************************************************************************** • function name   closeTreeScan  • description   close a tree scan  • parameters   BT_ScanHandle *handle  • return value   return RC_OK ***************************************************************************/RC closeTreeScan (BT_ScanHandle *handle){    free(handle);        return RC_OK;}